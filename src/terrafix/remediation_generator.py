"""
AWS Bedrock client for Terraform remediation generation.

This module constructs prompts with full context about compliance failures
and existing Terraform configuration, then uses Claude Sonnet 4.5 via AWS
Bedrock to generate compliant fixes in proper HCL format.

The generator maintains a library of Terraform documentation snippets for
common resource types to improve fix quality.

Usage:
    from terrafix.remediation_generator import TerraformRemediationGenerator

    generator = TerraformRemediationGenerator(
        model_id="anthropic.claude-sonnet-4-5-v2:0",
        region="us-west-2"
    )

    fix = generator.generate_fix(
        failure=failure,
        current_config=terraform_content,
        resource_block=resource_block,
        module_context=context
    )

    print(fix["fixed_config"])
"""

import json
from typing import Any

import boto3
from botocore.exceptions import ClientError
from pydantic import BaseModel, Field

from terrafix.errors import BedrockError
from terrafix.logging_config import get_logger, log_with_context
from terrafix.vanta_client import Failure

logger = get_logger(__name__)

# Maximum tokens for prompt to avoid exceeding model limits
MAX_PROMPT_TOKENS = 100000  # Conservative estimate for Sonnet 4.5


class RemediationFix(BaseModel):
    """
    Terraform remediation fix generated by Claude.

    Attributes:
        fixed_config: Complete updated Terraform file content
        explanation: Human-readable explanation of changes
        changed_attributes: List of attributes that were modified
        reasoning: Why these changes address the compliance failure
        confidence: high/medium/low confidence in the fix
        breaking_changes: Any potential breaking changes or migration notes
        additional_requirements: Any manual steps required after applying
    """

    fixed_config: str = Field(..., description="Updated Terraform configuration")
    explanation: str = Field(..., description="Human-readable explanation")
    changed_attributes: list[str] = Field(
        default_factory=list,
        description="Modified attributes",
    )
    reasoning: str = Field(
        default="",
        description="Why these changes fix the failure",
    )
    confidence: str = Field(..., description="high/medium/low")
    breaking_changes: str = Field(
        default="None identified",
        description="Potential breaking changes",
    )
    additional_requirements: str = Field(
        default="None",
        description="Manual steps required",
    )


class TerraformRemediationGenerator:
    """
    Generates Terraform configuration fixes using Claude via Bedrock.

    Uses AWS Bedrock to invoke Claude Sonnet 4.5 with carefully constructed
    prompts containing failure context and Terraform documentation.

    Attributes:
        bedrock_client: Boto3 Bedrock Runtime client
        model_id: Claude model identifier
    """

    def __init__(
        self,
        model_id: str = "anthropic.claude-sonnet-4-5-v2:0",
        region: str = "us-west-2",
    ) -> None:
        """
        Initialize Bedrock Claude client.

        Args:
            model_id: Claude model ID (default: Sonnet 4.5)
            region: AWS region for Bedrock

        Example:
            >>> generator = TerraformRemediationGenerator()
        """
        self.bedrock_client = boto3.client(
            service_name="bedrock-runtime",
            region_name=region,
        )
        self.model_id = model_id

        log_with_context(
            logger,
            "info",
            "Initialized Bedrock client",
            model_id=self.model_id,
            region=region,
        )

    def generate_fix(
        self,
        failure: Failure,
        current_config: str,
        resource_block: dict[str, Any],
        module_context: dict[str, Any],
    ) -> RemediationFix:
        """
        Generate Terraform configuration fix.

        Constructs a detailed prompt with failure context and current config,
        invokes Claude via Bedrock, and parses the response.

        Args:
            failure: Vanta test failure details
            current_config: Current Terraform file content
            resource_block: Specific resource block that failed
            module_context: Surrounding module context

        Returns:
            RemediationFix with fixed config and metadata

        Raises:
            BedrockError: If Bedrock API call fails

        Example:
            >>> fix = generator.generate_fix(
            ...     failure=failure,
            ...     current_config=content,
            ...     resource_block=block,
            ...     module_context=context
            ... )
        """
        log_with_context(
            logger,
            "info",
            "Generating Terraform fix",
            test_id=failure.test_id,
            resource_arn=failure.resource_arn,
            resource_type=failure.resource_type,
        )

        prompt = self._construct_prompt(
            failure,
            current_config,
            resource_block,
            module_context,
        )

        # Check prompt size and truncate if needed
        if len(prompt) > MAX_PROMPT_TOKENS * 4:  # Rough character estimate
            log_with_context(
                logger,
                "warning",
                "Prompt exceeds recommended size, truncating",
                original_size=len(prompt),
            )
            # Truncate current_config if it's too large
            if len(current_config) > 10000:
                current_config = current_config[:10000] + "\n\n... [truncated]"

        try:
            response = self._invoke_claude(prompt)
            fix = self._parse_response(response)

            log_with_context(
                logger,
                "info",
                "Successfully generated fix",
                test_id=failure.test_id,
                confidence=fix.confidence,
                changed_attributes=fix.changed_attributes,
            )

            return fix

        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code", "Unknown")
            request_id = e.response.get("ResponseMetadata", {}).get("RequestId")

            log_with_context(
                logger,
                "error",
                "Bedrock API error",
                error_code=error_code,
                request_id=request_id,
                error_message=str(e),
            )

            # Determine if error is retryable
            retryable = error_code in [
                "ThrottlingException",
                "ServiceUnavailableException",
                "InternalServerException",
            ]

            raise BedrockError(
                f"Bedrock API error: {e}",
                error_code=error_code,
                request_id=request_id,
                retryable=retryable,
            ) from e

    def _construct_prompt(
        self,
        failure: Failure,
        current_config: str,
        resource_block: dict[str, Any],
        module_context: dict[str, Any],
    ) -> str:
        """
        Construct detailed prompt for Claude.

        Includes compliance requirement details, current Terraform configuration,
        Terraform best practices context, and expected output format.

        Args:
            failure: Vanta failure details
            current_config: Current Terraform file content
            resource_block: Resource block that failed
            module_context: Module-level context

        Returns:
            Complete prompt string for Claude
        """
        terraform_docs = self._get_terraform_docs_for_resource(failure.resource_type)

        prompt = f"""You are a senior DevOps engineer and compliance expert specializing in Terraform and AWS security best practices.

# COMPLIANCE FAILURE

**Test**: {failure.test_name}
**Severity**: {failure.severity}
**Framework**: {failure.framework}
**Resource**: {failure.resource_arn}
**Resource Type**: {failure.resource_type}

**Failure Reason**: {failure.failure_reason}

**Current State**:
```json
{json.dumps(failure.current_state, indent=2)}
```

**Required State**:
```json
{json.dumps(failure.required_state, indent=2)}
```

# CURRENT TERRAFORM CONFIGURATION

```hcl
{current_config}
```

# RESOURCE BLOCK CONTEXT

```json
{json.dumps(resource_block, indent=2)}
```

# TASK

Generate a Terraform configuration fix that:
1. Addresses the compliance failure completely
2. Maintains existing resource dependencies
3. Follows Terraform best practices (style guide, naming conventions)
4. Uses proper HCL syntax compatible with Terraform 1.0+
5. Preserves any existing tags, lifecycle rules, or metadata
6. Includes appropriate inline comments explaining security controls

# TERRAFORM DOCUMENTATION CONTEXT

{terraform_docs}

# RESPONSE FORMAT (JSON)

Respond ONLY with valid JSON in this exact format (no markdown, no preamble):

{{
  "fixed_config": "<complete updated Terraform file content>",
  "explanation": "<human-readable explanation of changes>",
  "changed_attributes": ["attribute1", "attribute2"],
  "reasoning": "<why these changes address the compliance failure>",
  "confidence": "high|medium|low",
  "breaking_changes": "<any potential breaking changes or migration notes>",
  "additional_requirements": "<any manual steps required after applying>"
}}

# CRITICAL REQUIREMENTS

- The fix MUST be syntactically valid HCL
- Do NOT change resource names or identifiers
- Do NOT remove existing configuration unless necessary
- Preserve all comments and formatting where possible
- Use terraform fmt style conventions
- Only modify the minimum necessary to fix the compliance issue

Generate the JSON response now:"""

        log_with_context(
            logger,
            "debug",
            "Constructed prompt",
            prompt_length=len(prompt),
            test_id=failure.test_id,
        )

        return prompt

    def _get_terraform_docs_for_resource(self, resource_type: str) -> str:
        """
        Get relevant Terraform documentation for resource type.

        Returns documentation snippets for common AWS resource types.
        In production, this could fetch from Terraform Registry API.

        Args:
            resource_type: AWS resource type (AWS::S3::Bucket, etc.)

        Returns:
            Terraform documentation snippet
        """
        docs_map: dict[str, str] = {
            "AWS::S3::Bucket": """
## aws_s3_bucket Block Public Access

```hcl
resource "aws_s3_bucket_public_access_block" "example" {
  bucket = aws_s3_bucket.example.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}
```

## aws_s3_bucket Server-Side Encryption

```hcl
resource "aws_s3_bucket_server_side_encryption_configuration" "example" {
  bucket = aws_s3_bucket.example.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}
```

## aws_s3_bucket Versioning

```hcl
resource "aws_s3_bucket_versioning" "example" {
  bucket = aws_s3_bucket.example.id

  versioning_configuration {
    status = "Enabled"
  }
}
```
""",
            "AWS::IAM::Role": """
## aws_iam_role with Trust Policy

```hcl
resource "aws_iam_role" "example" {
  name = "example-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "lambda.amazonaws.com"
      }
    }]
  })
  
  # Recommended: Set maximum session duration
  max_session_duration = 3600
  
  tags = {
    Environment = "production"
  }
}
```

## aws_iam_role_policy_attachment

```hcl
resource "aws_iam_role_policy_attachment" "example" {
  role       = aws_iam_role.example.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}
```
""",
            "AWS::EC2::SecurityGroup": """
## aws_security_group Best Practices

```hcl
resource "aws_security_group" "example" {
  name        = "example-sg"
  description = "Security group for example"
  vpc_id      = aws_vpc.main.id

  # Avoid overly permissive rules
  ingress {
    description = "HTTPS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [aws_vpc.main.cidr_block]
  }

  egress {
    description = "Allow outbound"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "example-sg"
  }
}
```
""",
            "AWS::RDS::DBInstance": """
## aws_db_instance Security Settings

```hcl
resource "aws_db_instance" "example" {
  identifier = "example-db"
  
  # Enable encryption
  storage_encrypted = true
  kms_key_id       = aws_kms_key.db.arn
  
  # Enable backups
  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  
  # Enable deletion protection
  deletion_protection = true
  
  # Enable auto minor version upgrades
  auto_minor_version_upgrade = true
  
  # Enable enhanced monitoring
  monitoring_interval = 60
  monitoring_role_arn = aws_iam_role.rds_monitoring.arn
  
  # Enable CloudWatch logs
  enabled_cloudwatch_logs_exports = ["error", "general", "slowquery"]
}
```
""",
        }

        return docs_map.get(resource_type, "# No specific docs available")

    def _invoke_claude(self, prompt: str) -> dict[str, Any]:
        """
        Call Bedrock to invoke Claude Sonnet 4.5.

        Args:
            prompt: Constructed prompt with failure context

        Returns:
            Raw Bedrock API response

        Raises:
            BedrockError: If Bedrock API call fails
        """
        body = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "messages": [
                {
                    "role": "user",
                    "content": prompt,
                }
            ],
            "temperature": 0.1,  # Low temperature for consistency
            "top_p": 0.9,
        }

        log_with_context(
            logger,
            "debug",
            "Invoking Bedrock",
            model_id=self.model_id,
            max_tokens=body["max_tokens"],
            temperature=body["temperature"],
        )

        response = self.bedrock_client.invoke_model(
            modelId=self.model_id,
            body=json.dumps(body),
            contentType="application/json",
            accept="application/json",
        )

        return json.loads(response["body"].read())

    def _parse_response(self, response: dict[str, Any]) -> RemediationFix:
        """
        Extract structured fix from Claude's response.

        Handles various response formats and validates required fields.

        Args:
            response: Raw Bedrock response

        Returns:
            Parsed RemediationFix

        Raises:
            BedrockError: If response cannot be parsed or is invalid
        """
        content = response.get("content", [])
        if not content:
            raise BedrockError(
                "Empty Claude response",
                retryable=False,
            )

        text = content[0].get("text", "").strip()

        log_with_context(
            logger,
            "debug",
            "Parsing Claude response",
            response_length=len(text),
        )

        # Claude may wrap JSON in markdown code blocks
        if "```json" in text:
            text = text.split("```json")[1].split("```")[0].strip()
        elif "```" in text:
            text = text.split("```")[1].split("```")[0].strip()

        try:
            parsed = json.loads(text)
        except json.JSONDecodeError as e:
            log_with_context(
                logger,
                "error",
                "Invalid JSON from Claude",
                error=str(e),
                response_text=text[:500],
            )
            raise BedrockError(
                f"Invalid JSON from Claude: {e}",
                retryable=False,
            ) from e

        # Validate required fields
        required = ["fixed_config", "explanation", "confidence"]
        for field in required:
            if field not in parsed:
                raise BedrockError(
                    f"Missing required field in Claude response: {field}",
                    retryable=False,
                )

        # Create RemediationFix with validation
        try:
            return RemediationFix(**parsed)
        except Exception as e:
            log_with_context(
                logger,
                "error",
                "Failed to parse RemediationFix",
                error=str(e),
                parsed_keys=list(parsed.keys()),
            )
            raise BedrockError(
                f"Failed to parse RemediationFix: {e}",
                retryable=False,
            ) from e

